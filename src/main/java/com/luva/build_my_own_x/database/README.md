# Build Your Own Database From Scratch

See [Build Your Own Database From Scratch](https://build-your-own.org/database/)

* Persistence： 如何不丢失或损坏您的数据，以及从崩溃中恢复。
* Indexing：高效地查询和操作数据。
* Concurrency：如何处理大量的客户端连接以及事务。

## Indexing 索引

### Key-Value 存储和 关系型数据库

尽管关系型数据库支持多种类型的查询，但几乎所有的查询都可以分解为以下三种磁盘操作：
* 扫描整个数据集。（没有使用到索引时）
* 根据指定的 key 查索引。
* 按范围查询索引。（索引已排序）

### Hashtables

### B-Trees

Balanced binary trees 的查询和更新的时间复杂度可以达到 O(log(n))，并且可以范围查询。B-Tree 相当于是一个 n-tree。相较于二叉树（binary tree），n-ary tree：
* 较少的空间占用
* 在内存中更快
* 较少的磁盘 IO

### LSM-Trees

Log-structured merge-tree

#### 查询

1. 一个 LSM-Tree 包含多个级别的数据；
2. 每个级别的数据被排序并切分到多个文件；
3. 点查询会从最高级别开始，如果 key 没有被找到，会继续向下一级别搜索；
4. 范围查询从所有级别合并结果，界别高的在合并过程中会被使用。

每一级的数据都是排序的，keys 可以通过二分查找找到，范围查找就是按顺序进行文件 IO，所以是高效的。

#### 更新

1. 当更新一个 key 时，key 会先被插入到最高级别的数据中；
2. 如果文件的大小达到一个阈值，就和下一级别的进行合并；
3. 文件大小的阈值随着每个级别呈指数增长，这意味着数据量也呈指数增长。

* 最高级别的文件大小是比较小的，所以插入到最高级别文件的 IO 是很少的
* 数据最终被合并到低等级的文件，合并是线性 IO，这是个有点
* 高级别文件触发合并操作的频率更高，但合并的范围也更小
* 当文件合并到低级别的文件时，？？？
* 合并操作可以在后台完成，但低级别文件的合并会造成瞬时的高 IO 使用，这会降低系统的性能